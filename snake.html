<!DOCTYPE html>
<html lang="zh-TW">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>ğŸ¥·çƒè¡£è¡Œ(è²ªé£Ÿè›‡-å­¸æ ¡å®¢äº‹100å¥)</title>
    <link href="https://oikasu1.github.io/kasuexam/kasu/fonts/twhei.css" rel="stylesheet">
    <link href="snake.css" rel="stylesheet">
	<script src="data.js"></script>
</head>

<body>

    <div id="gameSettings">
        <h2>ğŸ¥·å­¸æ ¡å®¢äº‹ğŸ’¯</h2>
        <div>
            <label for="lessonSelect">é—œå¡ï¼š</label>
            <select id="lessonSelect"></select>
        </div>
        <div>
            <label for="questionSelect">é¡Œç›®ï¼š</label>
            <select id="questionSelect"></select>
        </div>
        <div>
            <label for="answerSelect">ç­”æ¡ˆï¼š</label>
            <select id="answerSelect"></select>
        </div>
        <div>
            <label for="blockCountSelect">æ•¸é‡ï¼š</label>
            <select id="blockCountSelect">
                <option value="2">2</option>
                <option value="3" selected>3</option>
				<option value="4">4</option>
            </select>
        </div>
        <div>
            <label for="speedSelect">é€Ÿåº¦ï¼š</label>
            <select id="speedSelect">
			    <option value="slow">æ…¢æ…¢è¶– ğŸ¦¥</option>
                <option value="slow">å¯¬å¯¬ ğŸˆ</option>
                <option value="normal" selected>æ™®é€š ğŸ¦“</option>
                <option value="quick">çœŸç·Š ğŸ›©ï¸</option>
                <option value="fast">è¶³ç·Š ğŸš€</option>
            </select>
        </div>
        <button id="startButton">è²ªé£Ÿè›‡ ;)</button>
    </div>




    <div id="container">
        <div id="header">
            <div id="scoreDisplay">âœ¨å¾—åˆ†: 0</div>
            <div id="wordDisplay"></div>
            <div id="timeDisplay">â±ï¸æ™‚é–“: 0</div>
        </div>
        <canvas id="gameCanvas"></canvas>
        <div id="correctFoodLabel" class="food-label"></div>
        <div id="wrongFoodLabel" class="food-label"></div>
        <div id="wrongFoodLabel2" class="food-label"></div>
		<div id="wrongFoodLabel3" class="food-label"></div>
    </div>


	<div id="customModal" class="modal">
	  <div class="modal-content">
		<h2 id="modalTitle"></h2>
		<p id="modalMessage"></p>
		<div id="starRating"></div>
		<button id="modalClose">é—œé–‰</button>
	  </div>
	</div>

    <script>


/*
const myData = `
åˆ†é¡	åœ‹èª	å®¢èª	æ‹¼éŸ³	æ³¨éŸ³	éŸ³æª”
ä¸€ã€å•å¥½ 00ç™¾å¥	ä½ å¥½	ä½ î‡´îˆ‹îˆ˜îˆµå¥½î†¥î‡‚î‡§	henË‹ hooË†	î„Šî„˜î„Ë‹ î„Šî„—Ë†	k009.mp3
ä¸€ã€å•å¥½ 00ç™¾å¥	è€å¸«æ—©	å…ˆî‡·îˆ†îˆ—îˆ´ç”Ÿî‡¾îˆ‹îˆ˜îˆ´ğ ¢•î†±î‡ˆî‡£æ—©î†­î‡‚î‡§	sienË‡ senË‡ ngauË‹ zooË†	î„î„¢î„Ë‡ î„”î„˜î„Ë‡ î„¦î„›Ë‹ î„’î„—Ë†	k010.mp3
`;
*/

        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const wordDisplay = document.getElementById('wordDisplay');
        const scoreDisplay = document.getElementById('scoreDisplay');
        const timeDisplay = document.getElementById('timeDisplay');
        const correctFoodLabel = document.getElementById('correctFoodLabel');
        const wrongFoodLabel = document.getElementById('wrongFoodLabel');
        const container = document.getElementById('container');

        let gridSize = 20;
        let snake, correctFood, wrongFood, dx, dy, score, baseSpeed, gameSpeed, gameInterval, elapsedTime, startTime;
        let currentWord, currentCorrectTranslation, currentWrongTranslation;
        let isAdjacent;

        const rightAudio = new Audio('right.mp3');
        const wrongAudio = new Audio('wrong.mp3');

        function playAudio(audio) {
            audio.currentTime = 0;
            audio.play();
        }

        let currentAudio = null;
        let headers = [];
        let wordPairs = [];
        let lessons = {};
        let allWords = [];
        let unusedWords = [];
        let isGameRunning = false;
		let iosTouch = false;
		let isSnakeYellow = false;
		let colorChangeTimeout;



        function playTwice() {
            if (currentAudio) {
                currentAudio.pause();
                currentAudio.currentTime = 0;
                currentAudio.play();
                currentAudio.onended = function() {
                    if (this.playCount === undefined) {
                        this.playCount = 1;
                        currentAudio.play(); // æ’­æ”¾ç¬¬äºŒæ¬¡
                    } else {
                        this.playCount = undefined; // é‡ç½®è¨ˆæ•¸
                    }
                };
            }
        }

		function processMyData() {
			const lines = myData.trim().split('\n');
			headers = lines[0].trim().split(/\t/);
			let wordId = 0;
			allWords = []; // é‡ç½®
			lessons = {}; // é‡ç½® lessons å°è±¡

			// è¼”åŠ©å‡½æ•¸ï¼šæª¢æŸ¥å–®è©æ˜¯å¦é‡è¤‡
			const isDuplicate = (word, wordList) => {
				return wordList.some(w => w.åœ‹èª === word.åœ‹èª && w.å®¢èª === word.å®¢èª);
			};

			lines.slice(1).forEach((line, index) => {
				const parts = line.trim().split(/\t/);
				if (parts.length >= 3) {
					const [lesson, ...rest] = parts;
					if (!lessons[lesson]) {
						lessons[lesson] = [];
					}
					const newWord = {
						id: wordId++,
						lesson,
						...Object.fromEntries(headers.slice(1).map((header, i) => [header, rest[i] || '']))
					};
					if (!isDuplicate(newWord, lessons[lesson])) {
						lessons[lesson].push(newWord);
						if (!isDuplicate(newWord, allWords)) {
							allWords.push(newWord);
						}
					}
				} else if (parts.length === 2) {
					const [value1, value2] = parts;
					const lesson = `ç¬¬${Math.floor(index / 10) + 1}çµ„`;
					if (!lessons[lesson]) {
						lessons[lesson] = [];
					}
					const newWord = {
						id: wordId++,
						lesson,
						[headers[0]]: value1,
						[headers[1]]: value2
					};
					if (!isDuplicate(newWord, lessons[lesson])) {
						lessons[lesson].push(newWord);
						if (!isDuplicate(newWord, allWords)) {
							allWords.push(newWord);
						}
					}
				}
			});
			populateSelects();
		}
        function populateSelects() {
            const lessonSelect = document.getElementById('lessonSelect');
            const questionSelect = document.getElementById('questionSelect');
            const answerSelect = document.getElementById('answerSelect');

            // æ¸…ç©ºç¾æœ‰é¸é …
            lessonSelect.innerHTML = '';
            questionSelect.innerHTML = '';
            answerSelect.innerHTML = '';

            // æ·»åŠ "å…¨éƒ¨"é¸é …åˆ°èª²åˆ¥
            const allOption = document.createElement('option');
            allOption.value = 'all';
            allOption.textContent = 'å…¨éƒ¨';
            lessonSelect.appendChild(allOption);

            // æ·»åŠ å…¶ä»–èª²ç¨‹é¸é …
            for (const lesson in lessons) {
                const option = document.createElement('option');
                option.value = lesson;
                option.textContent = lesson;
                lessonSelect.appendChild(option);
            }

            // ç²å–é"éŸ³æª”"å’Œ"åˆ†é¡"çš„æ¨™é¡Œ
            const validHeaders = headers.filter(header => header !== 'éŸ³æª”' && header !== 'åˆ†é¡');

			// æª¢æŸ¥æ˜¯å¦åŒ…å«æ‰€æœ‰å¿…è¦çš„æ¨™é¡Œ
			const hasAllRequiredHeaders = ['åœ‹èª', 'æ³¨éŸ³'].every(header => validHeaders.includes(header));

            // å¡«å……é¡Œç›®é¸å–®
            validHeaders.forEach(header => {
                const questionOption = document.createElement('option');
                questionOption.value = header;
                questionOption.textContent = header;
                questionSelect.appendChild(questionOption);
            });

			// è¨­ç½®é»˜èªé¸é …
			if (hasAllRequiredHeaders) {
				// å¦‚æœåŒ…å«æ‰€æœ‰å¿…è¦çš„æ¨™é¡Œ,è¨­ç½®é»˜èªå€¼
				questionSelect.value = 'æ³¨éŸ³';
			} else if (questionSelect.options.length > 0) {
				// å¦å‰‡,é¸æ“‡ç¬¬ä¸€å€‹é¸é …
				questionSelect.selectedIndex = 0;
			}

			// åˆå§‹å¡«å……ç­”æ¡ˆé¸å–®
			updateAnswerSelect();

			// å¦‚æœåŒ…å«æ‰€æœ‰å¿…è¦çš„æ¨™é¡Œ,è¨­ç½®ç­”æ¡ˆé»˜èªå€¼ç‚º"åœ‹èª"
			if (hasAllRequiredHeaders) {
				answerSelect.value = 'åœ‹èª';
			}

			// æ·»åŠ äº‹ä»¶ç›£è½å™¨
			questionSelect.addEventListener('change', updateAnswerSelect);
		}

        function updateAnswerSelect() {
            const questionSelect = document.getElementById('questionSelect');
            const answerSelect = document.getElementById('answerSelect');
            const selectedQuestion = questionSelect.value;
            const validHeaders = headers.filter(header => header !== 'éŸ³æª”' && header !== 'åˆ†é¡');

            // å„²å­˜ç­”æ¡ˆé¸å–®çš„ç•¶å‰é¸æ“‡
            const currentAnswerSelection = answerSelect.value;

            // æ¸…ç©ºç­”æ¡ˆé¸å–®
            answerSelect.innerHTML = '';

            // é‡æ–°å¡«å……ç­”æ¡ˆé¸å–®ï¼Œæ’é™¤åœ¨é¡Œç›®ä¸­é¸æ“‡çš„é¸é …
            validHeaders.forEach(header => {
                if (header !== selectedQuestion) {
                    const option = document.createElement('option');
                    option.value = header;
                    option.textContent = header;
                    answerSelect.appendChild(option);
                }
            });

            // å¦‚æœç­”æ¡ˆé¸å–®çš„ä¹‹å‰é¸æ“‡ä»ç„¶å¯ç”¨ï¼Œå‰‡é¸ä¸­å®ƒ
            if (Array.from(answerSelect.options).some(option => option.value === currentAnswerSelection)) {
                answerSelect.value = currentAnswerSelection;
            } else {
                // å¦å‰‡ï¼Œé¸æ“‡ç¬¬ä¸€å€‹å¯ç”¨é¸é …
                answerSelect.selectedIndex = 0;
            }
        }

        function updateSelectOptions(changedSelect, otherSelect) {
            const changedValue = changedSelect.value;
            const otherValue = otherSelect.value;
            const validHeaders = headers.filter(header => header !== 'éŸ³æª”' && header !== 'åˆ†é¡');

            // å„²å­˜å…¶ä»–é¸å–®çš„ç•¶å‰é¸æ“‡
            const currentOtherSelection = otherSelect.value;

            // æ¸…ç©ºå…¶ä»–é¸å–®
            otherSelect.innerHTML = '';

            // é‡æ–°å¡«å……å…¶ä»–é¸å–®ï¼Œæ’é™¤å·²åœ¨è®Šæ›´çš„é¸å–®ä¸­é¸æ“‡çš„é¸é …
            validHeaders.forEach(header => {
                if (header !== changedValue) {
                    const option = document.createElement('option');
                    option.value = header;
                    option.textContent = header;
                    otherSelect.appendChild(option);
                }
            });

            // å¦‚æœå…¶ä»–é¸å–®çš„ä¹‹å‰é¸æ“‡ä»ç„¶å¯ç”¨ï¼Œå‰‡é¸ä¸­å®ƒ
            if (Array.from(otherSelect.options).some(option => option.value === currentOtherSelection)) {
                otherSelect.value = currentOtherSelection;
            } else {
                // å¦å‰‡ï¼Œé¸æ“‡ç¬¬ä¸€å€‹å¯ç”¨é¸é …
                otherSelect.selectedIndex = 0;
            }
        }

        function getWordStats(wordId) {
            const stats = JSON.parse(localStorage.getItem(`word_${wordId}`)) || {
                correct: 0,
                wrong: 0
            };
            return stats;
        }

        function updateWordStats(wordId, isCorrect) {
            const stats = getWordStats(wordId);
            if (isCorrect) {
                stats.correct++;
            } else {
                stats.wrong++;
            }
            localStorage.setItem(`word_${wordId}`, JSON.stringify(stats));
        }

        // åœ¨æ–‡æª”åŠ è¼‰å®Œæˆå¾ŒåŸ·è¡Œ
        window.onload = function() {
            processMyData();
            populateSelects();

            // ç‚ºé–‹å§‹éŠæˆ²æŒ‰éˆ•æ·»åŠ äº‹ä»¶ç›£è½å™¨
            document.getElementById('startButton').addEventListener('click', function() {
                const speed = document.getElementById('speedSelect').value;				
                startGame(speed);
				document.addEventListener('click', playTwice);
            });
        };

		function initGame() {
			snake = [{ x: 10, y: 10 }];
			dx = 0;
			dy = 0;
			score = 0;
			gameSpeed = baseSpeed;
			startTime = Date.now();
			resetUnusedWords();
			generateNewWord();
		}

        function resetUnusedWords() {
            unusedWords = [...wordPairs];
        }

        function generateNewWord() {			
            playAudio(rightAudio);

            // åœæ­¢ç•¶å‰æ­£åœ¨æ’­æ”¾çš„éŸ³æª”ï¼ˆå¦‚æœæœ‰ï¼‰
            if (currentAudio) {
                currentAudio.pause();
                currentAudio.currentTime = 0;
            }

            // å¦‚æœæ‰€æœ‰å–®è©éƒ½å·²ç¶“ä½¿ç”¨éï¼Œé‡ç½®æœªä½¿ç”¨å–®è©åˆ—è¡¨
            if (unusedWords.length === 0) {
                resetUnusedWords();
            }


            // å¾æœªä½¿ç”¨çš„å–®è©ä¸­éš¨æ©Ÿé¸æ“‡ä¸€å€‹
            const randomIndex = Math.floor(Math.random() * unusedWords.length);
            const selectedWord = unusedWords[randomIndex];

            // å¾æœªä½¿ç”¨å–®è©åˆ—è¡¨ä¸­ç§»é™¤é€™å€‹å–®è©
            unusedWords.splice(randomIndex, 1);

            currentWord = selectedWord.question;
            currentCorrectTranslation = selectedWord.answer;
            currentWordId = selectedWord.id;

            wordDisplay.textContent = `ğŸ¥· ${currentWord}`;


            // æª¢æŸ¥æ˜¯å¦æœ‰å°æ‡‰çš„éŸ³æª”ä¸¦è¨­ç½®
            if (selectedWord['éŸ³æª”']) {
                //currentAudio = new Audio(`https://oikasu1.github.io/kasu100/${selectedWord['éŸ³æª”']}`);
				let audioUrl = getAudioUrl(selectedWord['éŸ³æª”']);
				currentAudio = new Audio(audioUrl);

                playTwice(); // ç›´æ¥èª¿ç”¨ playTwice()
            }

            // ç²å–é¸æ“‡çš„æ–¹å¡Šæ•¸é‡
            const selectedBlockCount = parseInt(document.getElementById('blockCountSelect').value);

            // ç”Ÿæˆæ­£ç¢ºç­”æ¡ˆçš„ä½ç½®
            correctFood = generateFoodPosition();

            // ç”ŸæˆéŒ¯èª¤ç­”æ¡ˆçš„ä½ç½®ï¼Œç¢ºä¿ y åº§æ¨™ä¸åŒ
			// ç”ŸæˆéŒ¯èª¤ç­”æ¡ˆçš„ä½ç½®
			wrongFood = generateFoodPosition();
			while (wrongFood.y === correctFood.y) {
				wrongFood = generateFoodPosition();
			}

			// ç”Ÿæˆç¬¬äºŒå€‹éŒ¯èª¤ç­”æ¡ˆçš„ä½ç½®
			if (selectedBlockCount >= 3) {
				wrongFood2 = generateFoodPosition();
				while (wrongFood2.y === correctFood.y || wrongFood2.y === wrongFood.y) {
					wrongFood2 = generateFoodPosition();
				}
			} else {
				wrongFood2 = null;
			}


			// ç”Ÿæˆç¬¬ä¸‰å€‹éŒ¯èª¤ç­”æ¡ˆçš„ä½ç½®
			if (selectedBlockCount === 4) {
				wrongFood3 = generateFoodPosition();
				while (wrongFood3.y === correctFood.y || wrongFood3.y === wrongFood.y || 
					   (wrongFood2 && wrongFood3.y === wrongFood2.y)) {
					wrongFood3 = generateFoodPosition();
				}
			} else {
				wrongFood3 = null;
			}



            // è¨­ç½®é£Ÿç‰©æ¨™ç±¤ä½ç½®å’Œå…§å®¹
            setFoodLabelPosition(correctFoodLabel, correctFood, currentCorrectTranslation);

            // ç‚ºéŒ¯èª¤ç­”æ¡ˆç”Ÿæˆä¸åŒçš„ç¿»è­¯
            let wrongTranslations = wordPairs.filter(pair => pair.id !== selectedWord.id).map(pair => pair.answer);
            currentWrongTranslation = wrongTranslations[Math.floor(Math.random() * wrongTranslations.length)];
            setFoodLabelPosition(wrongFoodLabel, wrongFood, currentWrongTranslation);


			if (selectedBlockCount >= 3 && wrongFood2) {
				let secondWrongTranslation;
				do {
					secondWrongTranslation = wrongTranslations[Math.floor(Math.random() * wrongTranslations.length)];
				} while (secondWrongTranslation === currentCorrectTranslation);
				setFoodLabelPosition(document.getElementById('wrongFoodLabel2'), wrongFood2, secondWrongTranslation);
				document.getElementById('wrongFoodLabel2').style.display = 'block';
			} else {
				document.getElementById('wrongFoodLabel2').style.display = 'none';
			}

			if (selectedBlockCount === 4 && wrongFood3) {
				let thirdWrongTranslation;
				do {
					thirdWrongTranslation = wrongTranslations[Math.floor(Math.random() * wrongTranslations.length)];
				} while (thirdWrongTranslation === currentCorrectTranslation || 
						 thirdWrongTranslation === document.getElementById('wrongFoodLabel2').textContent);
				setFoodLabelPosition(document.getElementById('wrongFoodLabel3'), wrongFood3, thirdWrongTranslation);
				document.getElementById('wrongFoodLabel3').style.display = 'block';
			} else {
				document.getElementById('wrongFoodLabel3').style.display = 'none';
			}
		}





// å–å¾—è·¯å¾‘;
function getAudioUrl(audioFileInfo) {
    if (audioFileInfo.endsWith('.k100')) {
        return `https://oikasu1.github.io/kasu100/${audioFileInfo.replace('.k100', '.mp3')}`;
    } else if (audioFileInfo.endsWith('.kasu')) {
        return `https://oikasu1.github.io/snd/mp3kasu/${audioFileInfo.replace('.kasu', '.mp3')}`;
    } else if (audioFileInfo.endsWith('.holo')) {
        return `https://oikasu1.github.io/snd/mp3holo/${audioFileInfo.replace('.holo', '.mp3')}`;
    } else if (audioFileInfo.endsWith('.mp3')) {
        return audioFileInfo;
    } else {
        let langCode, text;
        
        // æ–°å¢çš„ TTS è™•ç†é‚è¼¯
        const ttsMatch = audioFileInfo.match(/^tts\s*[:=]?\s*(\w+)\s*\)?$/i);
        if (ttsMatch) {
            langCode = ttsMatch[1].toLowerCase();
            text = gameData[currentQuestionIndex][headers.indexOf(langCode)];
        } else {
            switch (audioFileInfo) {
                case 'zh':
                    langCode = 'zh-TW';
                    text = gameData[currentQuestionIndex][headers.indexOf('åœ‹èª')];
                    break;
                case 'en':
                case 'è‹±':
                    langCode = 'en';
                    text = gameData[currentQuestionIndex][headers.indexOf('è‹±èª')] || gameData[currentQuestionIndex][headers.indexOf('ç¾èª')];
                    break;
                case 'jp':
                case 'æ—¥':
                    langCode = 'ja';
                    text = gameData[currentQuestionIndex][headers.indexOf('æ—¥èª')];
                    break;
                case 'es':
                case 'è¥¿':
                    langCode = 'es-ES';
                    text = gameData[currentQuestionIndex][headers.indexOf('è¥¿ç­ç‰™èª')];
                    break;
                case 'vi':
                case 'è¶Š':
                    langCode = 'vi';
                    text = gameData[currentQuestionIndex][headers.indexOf('è¶Šå—èª')];
                    break;
                case 'ko':
                case 'éŸ“':
                    langCode = 'vi';
                    text = gameData[currentQuestionIndex][headers.indexOf('éŸ“èª')];
                    break;
                case 'in':
                case 'å°':
                    langCode = 'id';
                    text = gameData[currentQuestionIndex][headers.indexOf('å°å°¼èª')];
                    break;
                default:
                    console.warn('æœªçŸ¥çš„éŸ³é »æ ¼å¼:', audioFileInfo);
                    return null;
            }
        }
        
        if (langCode && text) {
            return `https://translate.google.com/translate_tts?ie=UTF-8&tl=${langCode}&client=tw-ob&q=${encodeURIComponent(text)}`;
        } else {
            console.warn('ç„¡æ³•ç¢ºå®šèªè¨€æˆ–æ‰¾ä¸åˆ°å°æ‡‰çš„æ–‡æœ¬');
            return null;
        }
    }
}


        function generateFoodPosition() {
            const x = Math.floor(Math.random() * (canvas.width / gridSize));
            const y = Math.floor(Math.random() * (canvas.height / gridSize));
            return {
                x,
                y
            };
        }

        function checkCollision() {
            const head = snake[0];
            return (
                head.x < 0 || head.x >= canvas.width / gridSize ||
                head.y < 0 || head.y >= canvas.height / gridSize ||
                snake.slice(1).some(segment => segment.x === head.x && segment.y === head.y)
            );
        }



        function generateFoodPositions(count) {
            const positions = [];
            const maxY = canvas.height / gridSize - 1;
            const availableYs = [...Array(maxY + 1).keys()];

            for (let i = 0; i < count; i++) {
                if (availableYs.length === 0) {
                    console.warn('Not enough vertical space for all blocks');
                    break;
                }
                const yIndex = Math.floor(Math.random() * availableYs.length);
                const y = availableYs.splice(yIndex, 1)[0];
                const x = Math.floor(Math.random() * (canvas.width / gridSize));
                positions.push({
                    x,
                    y
                });
            }

            return positions;
        }


		function setFoodLabelPosition(label, food, text) {
			const labelOffset = 5; // å¯ä»¥æ ¹æ“šéœ€è¦èª¿æ•´é€™å€‹å€¼
			const canvasMiddle = canvas.width / 2;

			if (food.x * gridSize >= canvasMiddle) {
				// é£Ÿç‰©åœ¨ç•«å¸ƒå³åŠéƒ¨åˆ†ï¼Œæ¨™ç±¤æ”¾åœ¨å·¦é‚Š
				label.style.right = `${canvas.width - food.x * gridSize + labelOffset}px`;
				label.style.left = 'auto';
			} else {
				// é£Ÿç‰©åœ¨ç•«å¸ƒå·¦åŠéƒ¨åˆ†ï¼Œæ¨™ç±¤æ”¾åœ¨å³é‚Š
				label.style.left = `${food.x * gridSize + gridSize + labelOffset}px`;
				label.style.right = 'auto';
			}

			// è¨­ç½®å‚ç›´ä½ç½®å’Œæ–‡å­—
			label.style.top = `${food.y * gridSize + 44}px`;
			label.textContent = text;
		}

		function drawSnake() {
		  snake.forEach((segment, index) => {
			// å¦‚æœè›‡è™•æ–¼"é»ƒè‰²ç‹€æ…‹"ï¼Œå‰‡ä½¿ç”¨é»ƒè‰²ç¹ªè£½
			ctx.fillStyle = isSnakeYellow ? 'gold' : 'green';
			ctx.fillRect(segment.x * gridSize, segment.y * gridSize, gridSize - 2, gridSize - 2);
			// åœ¨è›‡é ­ä¸Šé¡¯ç¤ºå¾—åˆ†
			if (index === 0) {
			  ctx.fillStyle = 'white';
			  ctx.font = '12px Arial';
			  ctx.textAlign = 'center';
			  ctx.textBaseline = 'middle';
			  ctx.fillText(score.toString(), (segment.x * gridSize) + (gridSize / 2), (segment.y * gridSize) + (gridSize / 2));
			}
		  });
		}

		function drawFood() {
			ctx.fillStyle = 'red';
			ctx.fillRect(correctFood.x * gridSize, correctFood.y * gridSize, gridSize - 2, gridSize - 2);
			ctx.fillRect(wrongFood.x * gridSize, wrongFood.y * gridSize, gridSize - 2, gridSize - 2);

			const selectedBlockCount = parseInt(document.getElementById('blockCountSelect').value);
			if (selectedBlockCount >= 3 && wrongFood2) {
				ctx.fillRect(wrongFood2.x * gridSize, wrongFood2.y * gridSize, gridSize - 2, gridSize - 2);
			}
			if (selectedBlockCount === 4 && wrongFood3) {
				ctx.fillRect(wrongFood3.x * gridSize, wrongFood3.y * gridSize, gridSize - 2, gridSize - 2);
			}
		}

		function moveSnake() {
		  const head = { x: snake[0].x + dx, y: snake[0].y + dy };
		  snake.unshift(head);

		  if (head.x === correctFood.x && head.y === correctFood.y) {
			score++;
			iosTouch = false;
			updateWordStats(currentWordId, true);
			
			// å°‡è›‡è®Šç‚ºé»ƒè‰²
			isSnakeYellow = true;
			
			// æ¸…é™¤ä¹‹å‰çš„è¨ˆæ™‚å™¨ï¼ˆå¦‚æœå­˜åœ¨ï¼‰
			if (colorChangeTimeout) {
			  clearTimeout(colorChangeTimeout);
			}
			
			// è¨­ç½®æ–°çš„è¨ˆæ™‚å™¨ï¼Œ1ç§’å¾Œå°‡è›‡è®Šå›ç¶ è‰²
			colorChangeTimeout = setTimeout(() => {
			  isSnakeYellow = false;
			}, 500);

			generateNewWord();
			updateScore();
			// æ›´æ–°éŠæˆ²é€Ÿåº¦
			gameSpeed = Math.max(150, baseSpeed - score * 2);
			clearInterval(gameInterval);
			gameInterval = setInterval(gameLoop, gameSpeed);
		  } else if (head.x === wrongFood.x && head.y === wrongFood.y ||
			(wrongFood2 && head.x === wrongFood2.x && head.y === wrongFood2.y) ||
			(wrongFood3 && head.x === wrongFood3.x && head.y === wrongFood3.y)) {
			updateWordStats(currentWordId, false);
			endGame();
		  } else {
			snake.pop();
		  }
		}

        function gameLoop() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            moveSnake();
            drawSnake();
            drawFood();

            updateTime();

            if (checkCollision()) {
                endGame();
            }
        }



        function endGame() {
            playAudio(wrongAudio);
			iosTouch = false;

	  	   if (colorChangeTimeout) {
			 clearTimeout(colorChangeTimeout);
		   }

            if (currentAudio) {
                currentAudio.pause();
                currentAudio.currentTime = 0;
            }
            showCustomModal('ğŸ¥·éŠæˆ²ç…å•Š', `ğŸ‰ä½ å¾—è‘—: ${score} åˆ†`, score);
            clearInterval(gameInterval);
            isGameRunning = false;
            document.removeEventListener('keydown', handleKeyDown);
            // ç§»é™¤é»æ“Šäº‹ä»¶ç›£è½å™¨
            document.removeEventListener('click', playTwice);
        }




        function handleKeyDown(event) {
            if (!isGameRunning) return;

            switch (event.key) {
                case 'ArrowUp':
                    if (dy === 0) {
                        dx = 0;
                        dy = -1;
                    }
                    break;
                case 'ArrowDown':
                    if (dy === 0) {
                        dx = 0;
                        dy = 1;
                    }
                    break;
                case 'ArrowLeft':
                    if (dx === 0) {
                        dx = -1;
                        dy = 0;
                    }
                    break;
                case 'ArrowRight':
                    if (dx === 0) {
                        dx = 1;
                        dy = 0;
                    }
                    break;
                case ' ': // ç©ºæ ¼éµ
                    event.preventDefault(); // é˜²æ­¢é é¢æ»¾å‹•
                    playTwice();
                    break;
            }
        }

		

		function isIOS() {
			const userAgent = navigator.userAgent.toLowerCase();
			const isIOSDevice = /iphone|ipod/.test(userAgent);  // iPhone å’Œ iPod æª¢æ¸¬
			const isIPad = /ipad/.test(userAgent) || (navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1);  // iPad æª¢æ¸¬
			return isIOSDevice || isIPad;
		}





        function handleTouchStart(event) {
            touchStartX = event.touches[0].clientX;
            touchStartY = event.touches[0].clientY;

			if (isIOS() && !iosTouch) {
				playTwice();
				iosTouch = true;
			}

        }

        function handleTouchEnd(event) {
            const touchEndX = event.changedTouches[0].clientX;
            const touchEndY = event.changedTouches[0].clientY;
            const deltaX = touchEndX - touchStartX;
            const deltaY = touchEndY - touchStartY;

            if (Math.abs(deltaX) > Math.abs(deltaY)) {
                if (deltaX > 0 && dx === 0) {
                    dx = 1;
                    dy = 0;
                } else if (deltaX < 0 && dx === 0) {
                    dx = -1;
                    dy = 0;
                }
            } else {
                if (deltaY > 0 && dy === 0) {
                    dx = 0;
                    dy = 1;
                } else if (deltaY < 0 && dy === 0) {
                    dx = 0;
                    dy = -1;
                }
            }
        }


        function startGame(speed) {
            const selectedLesson = document.getElementById('lessonSelect').value;
            const selectedQuestion = document.getElementById('questionSelect').value;
            const selectedAnswer = document.getElementById('answerSelect').value;
            const selectedBlockCount = parseInt(document.getElementById('blockCountSelect').value);
            resizeCanvas();

            isGameRunning = true;
            document.addEventListener('keydown', handleKeyDown);

            if (selectedLesson === 'all') {
                wordPairs = allWords;
            } else {
                wordPairs = lessons[selectedLesson];
            }

            // æ›´æ–° currentWord å’Œ currentCorrectTranslation çš„è¨­ç½®
            wordPairs = wordPairs.map(word => ({
                ...word,
                question: word[selectedQuestion] || '',
                answer: word[selectedAnswer] || ''
            }));

			switch (speed) {
				case 'slow':
					baseSpeed = 400;
					break;
				case 'normal':
					baseSpeed = 300;
					break;
				case 'quick':
					baseSpeed = 250;
					break;
				case 'fast':
					baseSpeed = 200;
					break;
			}



            document.getElementById('gameSettings').style.display = 'none';
            canvas.style.display = 'block';
            container.style.display = 'block';
            correctFoodLabel.style.display = 'block';
            wrongFoodLabel.style.display = 'block';

            // æ·»åŠ é»æ“Šäº‹ä»¶ç›£è½å™¨
            //document.addEventListener('click', playTwice);

            resetUnusedWords();
            initGame();
            gameInterval = setInterval(gameLoop, gameSpeed);
        }

        function updateScore() {
            scoreDisplay.textContent = `âœ¨å¾—åˆ†: ${score}`;
        }

        function updateTime() {
            elapsedTime = Math.floor((Date.now() - startTime) / 1000);
            timeDisplay.textContent = `â±æ™‚é–“: ${elapsedTime}`;
        }

        document.addEventListener('keydown', handleKeyDown);
        document.addEventListener('touchstart', handleTouchStart, false);
        document.addEventListener('touchend', handleTouchEnd, false);

        document.body.addEventListener('touchmove', function(e) {
            e.preventDefault();
        }, {
            passive: false
        });



        function resizeCanvas() {
            const canvas = document.getElementById('gameCanvas');
            const container = document.getElementById('container');
            const windowWidth = window.innerWidth;
            const windowHeight = window.innerHeight;

            let canvasWidth, canvasHeight, containerWidth, containerHeight;

            if (windowWidth < windowHeight) { // ç›´å¼
                if (windowWidth < 600) { // å°è¢å¹•æ‰‹æ©Ÿ
                    canvasWidth = 300;
                    canvasHeight = 400;
                    containerWidth = 304;
                    containerHeight = 451;
                } else { // å¤§è¢å¹•æˆ–å¹³æ¿
                    canvasWidth = 400;
                    canvasHeight = 400;
                    containerWidth = 400;
                    containerHeight = 451;
                }
            } else { // æ©«å¼
                if (windowHeight < 450) { // å°è¢å¹•æ‰‹æ©Ÿ
                    canvasWidth = 450;
                    canvasHeight = 250;
                    containerWidth = 454;
                    containerHeight = 301;
                } else { // å¤§è¢å¹•æˆ–å¹³æ¿
                    canvasWidth = 400;
                    canvasHeight = 400;
                    containerWidth = 400;
                    containerHeight = 451;
                }
            }

            canvas.width = canvasWidth;
            canvas.height = canvasHeight;

            // æ›´æ–°å…¨å±€è®Šé‡ gridSize
            gridSize = Math.min(canvasWidth, canvasHeight) / 20;

            scaleElement(container, containerWidth, containerHeight);
        }


        function scaleElement(e, w, h) {
            const windowWidth = window.innerWidth;
            const windowHeight = window.innerHeight;

            let scaleX = windowWidth / w * 0.9;
            let scaleY = windowHeight / h * 0.9;

            const scale = Math.min(scaleX, scaleY);

            e.style.transform = `scale(${scale})`;
            container.style.marginTop = "10px";
        }

        // åœ¨é é¢è¼‰å…¥å’Œè¦–çª—å¤§å°æ”¹è®Šæ™‚èª¿ç”¨ resizeCanvas
        window.addEventListener('load', resizeCanvas);
        window.addEventListener('resize', resizeCanvas);



		function showCustomModal(title, message, score) {
		  const modal = document.getElementById('customModal');
		  const modalTitle = document.getElementById('modalTitle');
		  const modalMessage = document.getElementById('modalMessage');
		  const starRating = document.getElementById('starRating');
		  const modalClose = document.getElementById('modalClose');

		  modalTitle.textContent = title;
		  modalMessage.textContent = message;
		  
		  // æ¸…ç©ºä¹‹å‰çš„æ˜Ÿæ˜Ÿ
		  starRating.innerHTML = '';
		  
		  for (let i = 0; i < score; i++) {
			const star = document.createElement('span');
			star.textContent = 'â­';
			star.className = 'star';
			starRating.appendChild(star);
		  }
		  
		  modal.style.display = 'block';

		  modalClose.onclick = function() {
			modal.style.display = 'none';
			// åœ¨é€™è£¡æ·»åŠ ä»»ä½•åœ¨é—œé–‰æ¨¡æ…‹æ¡†å¾Œéœ€è¦åŸ·è¡Œçš„ä»£ç¢¼
            if (currentAudio) {
                currentAudio.pause();
                currentAudio.currentTime = 0;
            }
			container.style.display = 'none';
			canvas.style.display = 'none';
			document.getElementById('gameSettings').style.display = 'block';
			correctFoodLabel.style.display = 'none';
			wrongFoodLabel.style.display = 'none';
		  }

		  window.onclick = function(event) {
			if (event.target == modal) {
			  modal.style.display = 'none';
			  // åœ¨é€™è£¡æ·»åŠ ä»»ä½•åœ¨é—œé–‰æ¨¡æ…‹æ¡†å¾Œéœ€è¦åŸ·è¡Œçš„ä»£ç¢¼
				if (currentAudio) {
					currentAudio.pause();
					currentAudio.currentTime = 0;
				}
			  container.style.display = 'none';
			  canvas.style.display = 'none';
			  document.getElementById('gameSettings').style.display = 'block';
			  correctFoodLabel.style.display = 'none';
			  wrongFoodLabel.style.display = 'none';
			}
		  }
		}

// Define settings configuration for easy mapping
const settingsConfig = [
    { key: 'lesson', element: () => document.getElementById('lessonSelect') },
    { key: 'question', element: () => document.getElementById('questionSelect') },
    { key: 'answer', element: () => document.getElementById('answerSelect') },
    { key: 'blockCount', element: () => document.getElementById('blockCountSelect') },
    { key: 'speed', element: () => document.getElementById('speedSelect') }
];

// Save settings to localStorage
function saveSettings() {
    const titleElement = document.querySelector("#gameSettings h2");
    if (!titleElement) return;

    const storageKey = `gameSettings_${titleElement.textContent}`;
    
    // Collect all settings values
    const settings = {};
    settingsConfig.forEach(config => {
        settings[config.key] = config.element().value;
    });

    localStorage.setItem(storageKey, JSON.stringify(settings));
}

// Load settings from localStorage
function loadSettings() {
    const titleElement = document.querySelector("#gameSettings h2");
    if (!titleElement) return;

    const storageKey = `gameSettings_${titleElement.textContent}`;
    const savedSettings = localStorage.getItem(storageKey);
    if (!savedSettings) return;

    try {
        const settings = JSON.parse(savedSettings);
        
        // Apply all settings
        settingsConfig.forEach(({ key, element }) => {
            if (settings[key]) {
                const selectElement = element();
                const optionIndex = Array.from(selectElement.options).findIndex(option => option.value === settings[key]);
                if (optionIndex >= 0) selectElement.selectedIndex = optionIndex;
            }
        });
        
        // Update answer select options based on question selection
        updateAnswerSelect();
    } catch (error) {
        console.error("Error loading settings:", error);
    }
}

// Add event listeners to all settings elements
function addSettingsSaveListeners() {
    settingsConfig.forEach(config => {
        config.element().addEventListener("change", saveSettings);
    });
}

// Modify the window.onload function to include loading settings
window.onload = function() {
    processMyData();
    populateSelects();
    
    // Load saved settings
    loadSettings();
    
    // Add event listeners for saving settings
    addSettingsSaveListeners();

    // For start game button
    document.getElementById('startButton').addEventListener('click', function() {
        const speed = document.getElementById('speedSelect').value;                
        startGame(speed);
        document.addEventListener('click', playTwice);
    });
};




    </script>
</body>

</html>

